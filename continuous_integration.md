## Continuous Integration

Deno's built-in tools make it easy to set up Continuous Integration (CI)
pipelines for your projects. Testing, linting and formatting of code can all be
done with the corresponding commands `deno test`, `deno lint` and `deno fmt`. In
addition, you can generate code coverage reports from test results with
`deno coverage` in pipelines.

This page will show you how to set up basic pipelines for Deno projects in
GitHub Actions. The concepts explained on this page largely apply to other CI
providers as well, such as GitLab, CircleCI or Azure Pipelines.

Building a pipeline for Deno generally starts with checking out the repository
and installing Deno:

```yaml
name: Build

on: push

jobs:
  build:
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v2
      - uses: denoland/setup-deno@v1.0.0
        with:
          deno-version: v1.x # Run with latest stable Deno.
```

To expand the workflow just add any of the `deno` subcommands that you might
need:

```yaml
# This simply checks if the project code is formatted according to Deno's default
# formatting conventions.
- run: deno fmt --check

# This checks the code for syntax errors and style issues. If
# needed, you can pass a `deno.json` configuration file with custom linter
# rules.
- run: deno lint

# This runs any .test files in the repository and collects code coverage. The
# example runs with all permissions but granting the minimal permissions needed 
# (e.g. --allow-read) can help identify unexpected changes in permission requirements.
- name: Run tests and collect code coverage
  run: deno test --allow-all --coverage cov

# This generates a report from the collected coverage in `deno test --coverage`. It is
# saved in .lcov format, which can be uploaded to one of the various code coverage
# services that can track your coverage over time and provide more detailed analytics.
- name: Generate coverage report
  run: deno coverage --lcov cov > cov.lcov
```

### Testing Deno across platforms

As a Deno module maintainer, you probably want to know that your code works on
all of the major operating systems in use today: Linux, MacOS and Windows. A
cross-platform workflow can be achieved by running a matrix of parallel jobs,
each one running the build on a different OS:

```yaml
jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ ubuntu-20.04, macos-11, windows-2019 ]
    steps:
      # Build goes here.
```

> Note: GitHub Actions has a known issue with handling Windows-style line
> endings (CRLF). This may cause issues when running `deno fmt` in a pipeline
> with jobs that run on `windows`. To fix this, configure the Actions runner to
> use Linux-style line endings with `git config --system core.autocrlf false`
> and `git config --system core.eol lf` before using `actions/checkout@v2`.

If you should happen to work with experimental or unstable Deno APIs, you could
also include a run with the canary version of Deno to spot potential breaking
changes early on:

```yaml
jobs:
  build:
    runs-on: ${{ matrix.os }}
    continue-on-error: ${{ matrix.experimental }} # Continue the workflow if the canary run should fail.
    strategy:
      matrix:
        os: [ ubuntu-20.04, macos-11, windows-2019 ]
        deno-version: [ v1.x ] # Run the regular workflows on the latest stable.
        experimental: [ false ]
        # Add the canary version as an experimental run.
        include: 
          - deno-version: canary
            os: ubuntu-20.04
            experimental: true
```

### Reducing redundancies

While testing your code on all different platforms is important in
cross-platform testing, there are certain steps in a pipeline that don't need to
run for each OS. For example, generating the same coverage report on Linux,
MacOS and Windows is a bit redundant. You can use the `if` conditional keyword
of GitHub Actions in these cases. The following example shows how to run the
coverage generation and upload steps only on the Ubuntu (Linux) runner:

```yaml
- name: Generate coverage report
  if: matrix.os == 'ubuntu-20.04'
  run: deno coverage --lcov cov > cov.lcov

- name: Upload coverage to Coveralls.io
  if: matrix.os == 'ubuntu-20.04'
  uses: coverallsapp/github-action@master # Any code coverage service can be used, Coveralls.io is used as an example.
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }} # Generated by GitHub.
    path-to-lcov: cov.lcov
```

### Caching dependencies

As a project grows in size, more and more dependencies tend to be included. Deno
will download these dependencies during testing, and if a workflow is run many
times a day this can become a time-consuming process. A common solution to speed
things up in this case is to cache dependencies so that they do not need to be
downloaded anew.

As you may have read elsewhere in this manual, Deno stores dependencies locally
in a cache directory. In a pipeline this cache can be preserved between
workflows by setting the `DENO_DIR` environment variable and adding a caching
step to the workflow:

```yaml
# Set DENO_DIR to an absolute or relative path.
env:
  DENO_DIR: my_cache_directory

steps:
  - name: Cache Deno dependencies 
    uses: actions/cache@v2
    with:
      path: my_cache_directory
      key: ${{ runner.os }}-deno-cache-key
```

At first, when this workflow runs the cache is empty and commands like
`deno test` will still have to download dependencies, but after the job succeeds
the `DENO_DIR` will be saved and then can be restored in subsequent runs.

There is still an issue with the above approach: hardcoding the cache key means
that if a dependency is updated, the pipeline will restore a cache containing
the previous version of that dependency. The solution is to use a lockfile and
to generate a different key each time the cache need to be updated. You can find
more information on using lockfiles in Deno
[here](./linking_to_external_code/integrity_checking.md).

Once your project includes a lockfile, use GitHub Action's built-in `hashFiles`
function to make a new key every time the lockfile is changed:

```yaml
key: ${{ runner.os }}-${{ hashFiles('lock.json') }}
```
